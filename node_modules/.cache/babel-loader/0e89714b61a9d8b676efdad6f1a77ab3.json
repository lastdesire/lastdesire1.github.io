{"ast":null,"code":"import { PermissionStatus, createPermissionHook, EventEmitter, Platform } from 'expo-modules-core';\nimport { _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS } from '../AV';\nimport ExponentAV from '../ExponentAV';\nimport { isAudioEnabled, throwIfAudioIsDisabled } from './AudioAvailability';\nimport { RecordingOptionsPresets } from './RecordingConstants';\nimport { Sound } from './Sound';\nlet _recorderExists = false;\nconst eventEmitter = Platform.OS === 'android' ? new EventEmitter(ExponentAV) : null;\n/**\n * Checks user's permissions for audio recording.\n * @return A promise that resolves to an object of type `PermissionResponse`.\n */\nexport async function getPermissionsAsync() {\n  return ExponentAV.getPermissionsAsync();\n}\n/**\n * Asks the user to grant permissions for audio recording.\n * @return A promise that resolves to an object of type `PermissionResponse`.\n */\nexport async function requestPermissionsAsync() {\n  return ExponentAV.requestPermissionsAsync();\n}\n/**\n * Check or request permissions to record audio.\n * This uses both `requestPermissionAsync` and `getPermissionsAsync` to interact with the permissions.\n *\n * @example\n * ```ts\n * const [status, requestPermission] = Audio.usePermissions();\n * ```\n */\nexport const usePermissions = createPermissionHook({\n  getMethod: getPermissionsAsync,\n  requestMethod: requestPermissionsAsync\n});\n// @needsAudit\n/**\n * This class represents an audio recording. After creating an instance of this class, `prepareToRecordAsync`\n * must be called in order to record audio. Once recording is finished, call `stopAndUnloadAsync`. Note that\n * only one recorder is allowed to exist in the state between `prepareToRecordAsync` and `stopAndUnloadAsync`\n * at any given time.\n *\n * Note that your experience must request audio recording permissions in order for recording to function.\n * See the [`Permissions` module](/guides/permissions) for more details.\n *\n * Additionally, audio recording is [not supported in the iOS Simulator](/workflow/ios-simulator/#limitations).\n *\n * @example\n * ```ts\n * const recording = new Audio.Recording();\n * try {\n *   await recording.prepareToRecordAsync(Audio.RecordingOptionsPresets.HIGH_QUALITY);\n *   await recording.startAsync();\n *   // You are now recording!\n * } catch (error) {\n *   // An error occurred!\n * }\n * ```\n *\n * @return A newly constructed instance of `Audio.Recording`.\n */\nexport class Recording {\n  _subscription = null;\n  _canRecord = false;\n  _isDoneRecording = false;\n  _finalDurationMillis = 0;\n  _uri = null;\n  _onRecordingStatusUpdate = null;\n  _progressUpdateTimeoutVariable = null;\n  _progressUpdateIntervalMillis = _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS;\n  _options = null;\n  // Internal methods\n  _cleanupForUnloadedRecorder = async finalStatus => {\n    this._canRecord = false;\n    this._isDoneRecording = true;\n    this._finalDurationMillis = finalStatus?.durationMillis ?? 0;\n    _recorderExists = false;\n    if (this._subscription) {\n      this._subscription.remove();\n      this._subscription = null;\n    }\n    this._disablePolling();\n    return await this.getStatusAsync(); // Automatically calls onRecordingStatusUpdate for the final state.\n  };\n\n  _pollingLoop = async () => {\n    if (isAudioEnabled() && this._canRecord && this._onRecordingStatusUpdate != null) {\n      this._progressUpdateTimeoutVariable = setTimeout(this._pollingLoop, this._progressUpdateIntervalMillis);\n      try {\n        await this.getStatusAsync();\n      } catch {\n        this._disablePolling();\n      }\n    }\n  };\n  _disablePolling() {\n    if (this._progressUpdateTimeoutVariable != null) {\n      clearTimeout(this._progressUpdateTimeoutVariable);\n      this._progressUpdateTimeoutVariable = null;\n    }\n  }\n  _enablePollingIfNecessaryAndPossible() {\n    if (isAudioEnabled() && this._canRecord && this._onRecordingStatusUpdate != null) {\n      this._disablePolling();\n      this._pollingLoop();\n    }\n  }\n  _callOnRecordingStatusUpdateForNewStatus(status) {\n    if (this._onRecordingStatusUpdate != null) {\n      this._onRecordingStatusUpdate(status);\n    }\n  }\n  async _performOperationAndHandleStatusAsync(operation) {\n    throwIfAudioIsDisabled();\n    if (this._canRecord) {\n      const status = await operation();\n      this._callOnRecordingStatusUpdateForNewStatus(status);\n      return status;\n    } else {\n      throw new Error('Cannot complete operation because this recorder is not ready to record.');\n    }\n  }\n  /**\n   * Creates and starts a recording using the given options, with optional `onRecordingStatusUpdate` and `progressUpdateIntervalMillis`.\n   *\n   * ```ts\n   * const { recording, status } = await Audio.Recording.createAsync(\n   *   options,\n   *   onRecordingStatusUpdate,\n   *   progressUpdateIntervalMillis\n   * );\n   *\n   * // Which is equivalent to the following:\n   * const recording = new Audio.Recording();\n   * await recording.prepareToRecordAsync(options);\n   * recording.setOnRecordingStatusUpdate(onRecordingStatusUpdate);\n   * await recording.startAsync();\n   * ```\n   *\n   * @param options Options for the recording, including sample rate, bitrate, channels, format, encoder, and extension. If no options are passed to,\n   * the recorder will be created with options `Audio.RecordingOptionsPresets.LOW_QUALITY`. See below for details on `RecordingOptions`.\n   * @param onRecordingStatusUpdate A function taking a single parameter `status` (a dictionary, described in `getStatusAsync`).\n   * @param progressUpdateIntervalMillis The interval between calls of `onRecordingStatusUpdate`. This value defaults to 500 milliseconds.\n   *\n   * @example\n   * ```ts\n   * try {\n   *   const { recording: recordingObject, status } = await Audio.Recording.createAsync(\n   *     Audio.RecordingOptionsPresets.HIGH_QUALITY\n   *   );\n   *   // You are now recording!\n   * } catch (error) {\n   *   // An error occurred!\n   * }\n   * ```\n   *\n   * @return A `Promise` that is rejected if creation failed, or fulfilled with the following dictionary if creation succeeded.\n   */\n  static createAsync = async function () {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : RecordingOptionsPresets.LOW_QUALITY;\n    let onRecordingStatusUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let progressUpdateIntervalMillis = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    const recording = new Recording();\n    if (progressUpdateIntervalMillis) {\n      recording._progressUpdateIntervalMillis = progressUpdateIntervalMillis;\n    }\n    recording.setOnRecordingStatusUpdate(onRecordingStatusUpdate);\n    await recording.prepareToRecordAsync({\n      ...options,\n      keepAudioActiveHint: true\n    });\n    try {\n      const status = await recording.startAsync();\n      return {\n        recording,\n        status\n      };\n    } catch (err) {\n      recording.stopAndUnloadAsync();\n      throw err;\n    }\n  };\n  // Get status API\n  /**\n   * Gets the `status` of the `Recording`.\n   * @return A `Promise` that is resolved with the `RecordingStatus` object.\n   */\n  getStatusAsync = async () => {\n    // Automatically calls onRecordingStatusUpdate.\n    if (this._canRecord) {\n      return this._performOperationAndHandleStatusAsync(() => ExponentAV.getAudioRecordingStatus());\n    }\n    const status = {\n      canRecord: false,\n      isRecording: false,\n      isDoneRecording: this._isDoneRecording,\n      durationMillis: this._finalDurationMillis\n    };\n    this._callOnRecordingStatusUpdateForNewStatus(status);\n    return status;\n  };\n  /**\n   * Sets a function to be called regularly with the `RecordingStatus` of the `Recording`.\n   *\n   * `onRecordingStatusUpdate` will be called when another call to the API for this recording completes (such as `prepareToRecordAsync()`,\n   * `startAsync()`, `getStatusAsync()`, or `stopAndUnloadAsync()`), and will also be called at regular intervals while the recording can record.\n   * Call `setProgressUpdateInterval()` to modify the interval with which `onRecordingStatusUpdate` is called while the recording can record.\n   *\n   * @param onRecordingStatusUpdate A function taking a single parameter `RecordingStatus`.\n   */\n  setOnRecordingStatusUpdate(onRecordingStatusUpdate) {\n    this._onRecordingStatusUpdate = onRecordingStatusUpdate;\n    if (onRecordingStatusUpdate == null) {\n      this._disablePolling();\n    } else {\n      this._enablePollingIfNecessaryAndPossible();\n    }\n    this.getStatusAsync();\n  }\n  /**\n   * Sets the interval with which `onRecordingStatusUpdate` is called while the recording can record.\n   * See `setOnRecordingStatusUpdate` for details. This value defaults to 500 milliseconds.\n   * @param progressUpdateIntervalMillis The new interval between calls of `onRecordingStatusUpdate`.\n   */\n  setProgressUpdateInterval(progressUpdateIntervalMillis) {\n    this._progressUpdateIntervalMillis = progressUpdateIntervalMillis;\n    this.getStatusAsync();\n  }\n  // Record API\n  /**\n   * Loads the recorder into memory and prepares it for recording. This must be called before calling `startAsync()`.\n   * This method can only be called if the `Recording` instance has never yet been prepared.\n   *\n   * @param options `RecordingOptions` for the recording, including sample rate, bitrate, channels, format, encoder, and extension.\n   * If no options are passed to `prepareToRecordAsync()`, the recorder will be created with options `Audio.RecordingOptionsPresets.LOW_QUALITY`.\n   *\n   * @return A `Promise` that is fulfilled when the recorder is loaded and prepared, or rejects if this failed. If another `Recording` exists\n   * in your experience that is currently prepared to record, the `Promise` will reject. If the `RecordingOptions` provided are invalid,\n   * the `Promise` will also reject. The promise is resolved with the `RecordingStatus` of the recording.\n   */\n  async prepareToRecordAsync() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : RecordingOptionsPresets.LOW_QUALITY;\n    throwIfAudioIsDisabled();\n    if (_recorderExists) {\n      throw new Error('Only one Recording object can be prepared at a given time.');\n    }\n    if (this._isDoneRecording) {\n      throw new Error('This Recording object is done recording; you must make a new one.');\n    }\n    if (!options || !options.android || !options.ios) {\n      throw new Error('You must provide recording options for android and ios in order to prepare to record.');\n    }\n    const extensionRegex = /^\\.\\w+$/;\n    if (!options.android.extension || !options.ios.extension || !extensionRegex.test(options.android.extension) || !extensionRegex.test(options.ios.extension)) {\n      throw new Error(`Your file extensions must match ${extensionRegex.toString()}.`);\n    }\n    if (!this._canRecord) {\n      if (eventEmitter) {\n        this._subscription = eventEmitter.addListener('Expo.Recording.recorderUnloaded', this._cleanupForUnloadedRecorder);\n      }\n      const {\n        uri,\n        status\n      } = await ExponentAV.prepareAudioRecorder(options);\n      _recorderExists = true;\n      this._uri = uri;\n      this._options = options;\n      this._canRecord = true;\n      const currentStatus = {\n        ...status,\n        canRecord: true\n      };\n      this._callOnRecordingStatusUpdateForNewStatus(currentStatus);\n      this._enablePollingIfNecessaryAndPossible();\n      return currentStatus;\n    } else {\n      throw new Error('This Recording object is already prepared to record.');\n    }\n  }\n  /**\n   * Returns a list of available recording inputs. This method can only be called if the `Recording` has been prepared.\n   * @return A `Promise` that is fulfilled with an array of `RecordingInput` objects.\n   */\n  async getAvailableInputs() {\n    return ExponentAV.getAvailableInputs();\n  }\n  /**\n   * Returns the currently-selected recording input. This method can only be called if the `Recording` has been prepared.\n   * @return A `Promise` that is fulfilled with a `RecordingInput` object.\n   */\n  async getCurrentInput() {\n    return ExponentAV.getCurrentInput();\n  }\n  /**\n   * Sets the current recording input.\n   * @param inputUid The uid of a `RecordingInput`.\n   * @return A `Promise` that is resolved if successful or rejected if not.\n   */\n  async setInput(inputUid) {\n    return ExponentAV.setInput(inputUid);\n  }\n  /**\n   * Begins recording. This method can only be called if the `Recording` has been prepared.\n   * @return A `Promise` that is fulfilled when recording has begun, or rejects if recording could not be started.\n   * The promise is resolved with the `RecordingStatus` of the recording.\n   */\n  async startAsync() {\n    return this._performOperationAndHandleStatusAsync(() => ExponentAV.startAudioRecording());\n  }\n  /**\n   * Pauses recording. This method can only be called if the `Recording` has been prepared.\n   *\n   * > This is only available on Android API version 24 and later.\n   *\n   * @return A `Promise` that is fulfilled when recording has paused, or rejects if recording could not be paused.\n   * If the Android API version is less than 24, the `Promise` will reject. The promise is resolved with the\n   * `RecordingStatus` of the recording.\n   */\n  async pauseAsync() {\n    return this._performOperationAndHandleStatusAsync(() => ExponentAV.pauseAudioRecording());\n  }\n  /**\n   * Stops the recording and deallocates the recorder from memory. This reverts the `Recording` instance\n   * to an unprepared state, and another `Recording` instance must be created in order to record again.\n   * This method can only be called if the `Recording` has been prepared.\n   *\n   * > On Android this method may fail with `E_AUDIO_NODATA` when called too soon after `startAsync` and\n   * > no audio data has been recorded yet. In that case the recorded file will be invalid and should be discarded.\n   *\n   * @return A `Promise` that is fulfilled when recording has stopped, or rejects if recording could not be stopped.\n   * The promise is resolved with the `RecordingStatus` of the recording.\n   */\n  async stopAndUnloadAsync() {\n    if (!this._canRecord) {\n      if (this._isDoneRecording) {\n        throw new Error('Cannot unload a Recording that has already been unloaded.');\n      } else {\n        throw new Error('Cannot unload a Recording that has not been prepared.');\n      }\n    }\n    // We perform a separate native API call so that the state of the Recording can be updated with\n    // the final duration of the recording. (We cast stopStatus as Object to appease Flow)\n    let stopResult;\n    let stopError;\n    try {\n      stopResult = await ExponentAV.stopAudioRecording();\n    } catch (err) {\n      stopError = err;\n    }\n    // Web has to return the URI at the end of recording, so needs a little destructuring\n    if (Platform.OS === 'web' && stopResult?.uri !== undefined) {\n      this._uri = stopResult.uri;\n    }\n    // Clean-up and return status\n    await ExponentAV.unloadAudioRecorder();\n    const status = await this._cleanupForUnloadedRecorder(stopResult);\n    return stopError ? Promise.reject(stopError) : status;\n  }\n  // Read API\n  /**\n   * Gets the local URI of the `Recording`. Note that this will only succeed once the `Recording` is prepared\n   * to record. On web, this will not return the URI until the recording is finished.\n   * @return A `string` with the local URI of the `Recording`, or `null` if the `Recording` is not prepared\n   * to record (or, on Web, if the recording has not finished).\n   */\n  getURI() {\n    return this._uri;\n  }\n  /**\n   * @deprecated Use `createNewLoadedSoundAsync()` instead.\n   */\n  async createNewLoadedSound() {\n    let initialStatus = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let onPlaybackStatusUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    console.warn(`createNewLoadedSound is deprecated in favor of createNewLoadedSoundAsync, which has the same API aside from the method name`);\n    return this.createNewLoadedSoundAsync(initialStatus, onPlaybackStatusUpdate);\n  }\n  /**\n   * Creates and loads a new `Sound` object to play back the `Recording`. Note that this will only succeed once the `Recording`\n   * is done recording and `stopAndUnloadAsync()` has been called.\n   *\n   * @param initialStatus The initial intended `PlaybackStatusToSet` of the sound, whose values will override the default initial playback status.\n   * This value defaults to `{}` if no parameter is passed. See the [AV documentation](/versions/latest/sdk/av) for details on `PlaybackStatusToSet`\n   * and the default initial playback status.\n   * @param onPlaybackStatusUpdate A function taking a single parameter `PlaybackStatus`. This value defaults to `null` if no parameter is passed.\n   * See the [AV documentation](/versions/latest/sdk/av) for details on the functionality provided by `onPlaybackStatusUpdate`\n   *\n   * @return A `Promise` that is rejected if creation failed, or fulfilled with the `SoundObject`.\n   */\n  async createNewLoadedSoundAsync() {\n    let initialStatus = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let onPlaybackStatusUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    if (this._uri == null || !this._isDoneRecording) {\n      throw new Error('Cannot create sound when the Recording has not finished!');\n    }\n    return Sound.createAsync(\n    // $FlowFixMe: Flow can't distinguish between this literal and Asset\n    {\n      uri: this._uri\n    }, initialStatus, onPlaybackStatusUpdate, false);\n  }\n}\nexport { PermissionStatus };\nexport * from './RecordingConstants';\nexport * from './Recording.types';","map":{"version":3,"mappings":"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","names":["PermissionStatus","createPermissionHook","EventEmitter","Platform","_DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS","ExponentAV","isAudioEnabled","throwIfAudioIsDisabled","RecordingOptionsPresets","Sound","_recorderExists","eventEmitter","OS","getPermissionsAsync","requestPermissionsAsync","usePermissions","getMethod","requestMethod","Recording","_subscription","_canRecord","_isDoneRecording","_finalDurationMillis","_uri","_onRecordingStatusUpdate","_progressUpdateTimeoutVariable","_progressUpdateIntervalMillis","_options","_cleanupForUnloadedRecorder","finalStatus","durationMillis","remove","_disablePolling","getStatusAsync","_pollingLoop","setTimeout","clearTimeout","_enablePollingIfNecessaryAndPossible","_callOnRecordingStatusUpdateForNewStatus","status","_performOperationAndHandleStatusAsync","operation","Error","createAsync","options","LOW_QUALITY","onRecordingStatusUpdate","progressUpdateIntervalMillis","recording","setOnRecordingStatusUpdate","prepareToRecordAsync","keepAudioActiveHint","startAsync","err","stopAndUnloadAsync","getAudioRecordingStatus","canRecord","isRecording","isDoneRecording","setProgressUpdateInterval","android","ios","extensionRegex","extension","test","toString","addListener","uri","prepareAudioRecorder","currentStatus","getAvailableInputs","getCurrentInput","setInput","inputUid","startAudioRecording","pauseAsync","pauseAudioRecording","stopResult","stopError","stopAudioRecording","undefined","unloadAudioRecorder","Promise","reject","getURI","createNewLoadedSound","initialStatus","onPlaybackStatusUpdate","console","warn","createNewLoadedSoundAsync"],"sources":["/Users/noname/WebstormProjects/webapplastdesire/node_modules/expo-av/src/Audio/Recording.ts"],"sourcesContent":["import {\n  PermissionResponse,\n  PermissionStatus,\n  PermissionHookOptions,\n  createPermissionHook,\n  EventEmitter,\n  Subscription,\n  Platform,\n} from 'expo-modules-core';\n\nimport {\n  _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS,\n  AVPlaybackStatus,\n  AVPlaybackStatusToSet,\n} from '../AV';\nimport ExponentAV from '../ExponentAV';\nimport { isAudioEnabled, throwIfAudioIsDisabled } from './AudioAvailability';\nimport {\n  RecordingInput,\n  RecordingObject,\n  RecordingOptions,\n  RecordingStatus,\n} from './Recording.types';\nimport { RecordingOptionsPresets } from './RecordingConstants';\nimport { Sound, SoundObject } from './Sound';\n\nlet _recorderExists: boolean = false;\nconst eventEmitter = Platform.OS === 'android' ? new EventEmitter(ExponentAV) : null;\n\n/**\n * Checks user's permissions for audio recording.\n * @return A promise that resolves to an object of type `PermissionResponse`.\n */\nexport async function getPermissionsAsync(): Promise<PermissionResponse> {\n  return ExponentAV.getPermissionsAsync();\n}\n\n/**\n * Asks the user to grant permissions for audio recording.\n * @return A promise that resolves to an object of type `PermissionResponse`.\n */\nexport async function requestPermissionsAsync(): Promise<PermissionResponse> {\n  return ExponentAV.requestPermissionsAsync();\n}\n\n/**\n * Check or request permissions to record audio.\n * This uses both `requestPermissionAsync` and `getPermissionsAsync` to interact with the permissions.\n *\n * @example\n * ```ts\n * const [status, requestPermission] = Audio.usePermissions();\n * ```\n */\nexport const usePermissions = createPermissionHook({\n  getMethod: getPermissionsAsync,\n  requestMethod: requestPermissionsAsync,\n});\n\n// @needsAudit\n/**\n * This class represents an audio recording. After creating an instance of this class, `prepareToRecordAsync`\n * must be called in order to record audio. Once recording is finished, call `stopAndUnloadAsync`. Note that\n * only one recorder is allowed to exist in the state between `prepareToRecordAsync` and `stopAndUnloadAsync`\n * at any given time.\n *\n * Note that your experience must request audio recording permissions in order for recording to function.\n * See the [`Permissions` module](/guides/permissions) for more details.\n *\n * Additionally, audio recording is [not supported in the iOS Simulator](/workflow/ios-simulator/#limitations).\n *\n * @example\n * ```ts\n * const recording = new Audio.Recording();\n * try {\n *   await recording.prepareToRecordAsync(Audio.RecordingOptionsPresets.HIGH_QUALITY);\n *   await recording.startAsync();\n *   // You are now recording!\n * } catch (error) {\n *   // An error occurred!\n * }\n * ```\n *\n * @return A newly constructed instance of `Audio.Recording`.\n */\nexport class Recording {\n  _subscription: Subscription | null = null;\n  _canRecord: boolean = false;\n  _isDoneRecording: boolean = false;\n  _finalDurationMillis: number = 0;\n  _uri: string | null = null;\n  _onRecordingStatusUpdate: ((status: RecordingStatus) => void) | null = null;\n  _progressUpdateTimeoutVariable: number | null = null;\n  _progressUpdateIntervalMillis: number = _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS;\n  _options: RecordingOptions | null = null;\n\n  // Internal methods\n\n  _cleanupForUnloadedRecorder = async (finalStatus?: RecordingStatus) => {\n    this._canRecord = false;\n    this._isDoneRecording = true;\n    this._finalDurationMillis = finalStatus?.durationMillis ?? 0;\n    _recorderExists = false;\n    if (this._subscription) {\n      this._subscription.remove();\n      this._subscription = null;\n    }\n    this._disablePolling();\n    return await this.getStatusAsync(); // Automatically calls onRecordingStatusUpdate for the final state.\n  };\n\n  _pollingLoop = async () => {\n    if (isAudioEnabled() && this._canRecord && this._onRecordingStatusUpdate != null) {\n      this._progressUpdateTimeoutVariable = setTimeout(\n        this._pollingLoop,\n        this._progressUpdateIntervalMillis\n      ) as any;\n      try {\n        await this.getStatusAsync();\n      } catch {\n        this._disablePolling();\n      }\n    }\n  };\n\n  _disablePolling() {\n    if (this._progressUpdateTimeoutVariable != null) {\n      clearTimeout(this._progressUpdateTimeoutVariable);\n      this._progressUpdateTimeoutVariable = null;\n    }\n  }\n\n  _enablePollingIfNecessaryAndPossible() {\n    if (isAudioEnabled() && this._canRecord && this._onRecordingStatusUpdate != null) {\n      this._disablePolling();\n      this._pollingLoop();\n    }\n  }\n\n  _callOnRecordingStatusUpdateForNewStatus(status: RecordingStatus) {\n    if (this._onRecordingStatusUpdate != null) {\n      this._onRecordingStatusUpdate(status);\n    }\n  }\n\n  async _performOperationAndHandleStatusAsync(\n    operation: () => Promise<RecordingStatus>\n  ): Promise<RecordingStatus> {\n    throwIfAudioIsDisabled();\n    if (this._canRecord) {\n      const status = await operation();\n      this._callOnRecordingStatusUpdateForNewStatus(status);\n      return status;\n    } else {\n      throw new Error('Cannot complete operation because this recorder is not ready to record.');\n    }\n  }\n\n  /**\n   * Creates and starts a recording using the given options, with optional `onRecordingStatusUpdate` and `progressUpdateIntervalMillis`.\n   *\n   * ```ts\n   * const { recording, status } = await Audio.Recording.createAsync(\n   *   options,\n   *   onRecordingStatusUpdate,\n   *   progressUpdateIntervalMillis\n   * );\n   *\n   * // Which is equivalent to the following:\n   * const recording = new Audio.Recording();\n   * await recording.prepareToRecordAsync(options);\n   * recording.setOnRecordingStatusUpdate(onRecordingStatusUpdate);\n   * await recording.startAsync();\n   * ```\n   *\n   * @param options Options for the recording, including sample rate, bitrate, channels, format, encoder, and extension. If no options are passed to,\n   * the recorder will be created with options `Audio.RecordingOptionsPresets.LOW_QUALITY`. See below for details on `RecordingOptions`.\n   * @param onRecordingStatusUpdate A function taking a single parameter `status` (a dictionary, described in `getStatusAsync`).\n   * @param progressUpdateIntervalMillis The interval between calls of `onRecordingStatusUpdate`. This value defaults to 500 milliseconds.\n   *\n   * @example\n   * ```ts\n   * try {\n   *   const { recording: recordingObject, status } = await Audio.Recording.createAsync(\n   *     Audio.RecordingOptionsPresets.HIGH_QUALITY\n   *   );\n   *   // You are now recording!\n   * } catch (error) {\n   *   // An error occurred!\n   * }\n   * ```\n   *\n   * @return A `Promise` that is rejected if creation failed, or fulfilled with the following dictionary if creation succeeded.\n   */\n  static createAsync = async (\n    options: RecordingOptions = RecordingOptionsPresets.LOW_QUALITY,\n    onRecordingStatusUpdate: ((status: RecordingStatus) => void) | null = null,\n    progressUpdateIntervalMillis: number | null = null\n  ): Promise<RecordingObject> => {\n    const recording: Recording = new Recording();\n    if (progressUpdateIntervalMillis) {\n      recording._progressUpdateIntervalMillis = progressUpdateIntervalMillis;\n    }\n    recording.setOnRecordingStatusUpdate(onRecordingStatusUpdate);\n    await recording.prepareToRecordAsync({\n      ...options,\n      keepAudioActiveHint: true,\n    });\n    try {\n      const status = await recording.startAsync();\n      return { recording, status };\n    } catch (err) {\n      recording.stopAndUnloadAsync();\n      throw err;\n    }\n  };\n\n  // Get status API\n\n  /**\n   * Gets the `status` of the `Recording`.\n   * @return A `Promise` that is resolved with the `RecordingStatus` object.\n   */\n  getStatusAsync = async (): Promise<RecordingStatus> => {\n    // Automatically calls onRecordingStatusUpdate.\n    if (this._canRecord) {\n      return this._performOperationAndHandleStatusAsync(() => ExponentAV.getAudioRecordingStatus());\n    }\n    const status = {\n      canRecord: false,\n      isRecording: false,\n      isDoneRecording: this._isDoneRecording,\n      durationMillis: this._finalDurationMillis,\n    };\n    this._callOnRecordingStatusUpdateForNewStatus(status);\n    return status;\n  };\n\n  /**\n   * Sets a function to be called regularly with the `RecordingStatus` of the `Recording`.\n   *\n   * `onRecordingStatusUpdate` will be called when another call to the API for this recording completes (such as `prepareToRecordAsync()`,\n   * `startAsync()`, `getStatusAsync()`, or `stopAndUnloadAsync()`), and will also be called at regular intervals while the recording can record.\n   * Call `setProgressUpdateInterval()` to modify the interval with which `onRecordingStatusUpdate` is called while the recording can record.\n   *\n   * @param onRecordingStatusUpdate A function taking a single parameter `RecordingStatus`.\n   */\n  setOnRecordingStatusUpdate(onRecordingStatusUpdate: ((status: RecordingStatus) => void) | null) {\n    this._onRecordingStatusUpdate = onRecordingStatusUpdate;\n    if (onRecordingStatusUpdate == null) {\n      this._disablePolling();\n    } else {\n      this._enablePollingIfNecessaryAndPossible();\n    }\n    this.getStatusAsync();\n  }\n\n  /**\n   * Sets the interval with which `onRecordingStatusUpdate` is called while the recording can record.\n   * See `setOnRecordingStatusUpdate` for details. This value defaults to 500 milliseconds.\n   * @param progressUpdateIntervalMillis The new interval between calls of `onRecordingStatusUpdate`.\n   */\n  setProgressUpdateInterval(progressUpdateIntervalMillis: number) {\n    this._progressUpdateIntervalMillis = progressUpdateIntervalMillis;\n    this.getStatusAsync();\n  }\n\n  // Record API\n\n  /**\n   * Loads the recorder into memory and prepares it for recording. This must be called before calling `startAsync()`.\n   * This method can only be called if the `Recording` instance has never yet been prepared.\n   *\n   * @param options `RecordingOptions` for the recording, including sample rate, bitrate, channels, format, encoder, and extension.\n   * If no options are passed to `prepareToRecordAsync()`, the recorder will be created with options `Audio.RecordingOptionsPresets.LOW_QUALITY`.\n   *\n   * @return A `Promise` that is fulfilled when the recorder is loaded and prepared, or rejects if this failed. If another `Recording` exists\n   * in your experience that is currently prepared to record, the `Promise` will reject. If the `RecordingOptions` provided are invalid,\n   * the `Promise` will also reject. The promise is resolved with the `RecordingStatus` of the recording.\n   */\n  async prepareToRecordAsync(\n    options: RecordingOptions = RecordingOptionsPresets.LOW_QUALITY\n  ): Promise<RecordingStatus> {\n    throwIfAudioIsDisabled();\n\n    if (_recorderExists) {\n      throw new Error('Only one Recording object can be prepared at a given time.');\n    }\n\n    if (this._isDoneRecording) {\n      throw new Error('This Recording object is done recording; you must make a new one.');\n    }\n\n    if (!options || !options.android || !options.ios) {\n      throw new Error(\n        'You must provide recording options for android and ios in order to prepare to record.'\n      );\n    }\n\n    const extensionRegex = /^\\.\\w+$/;\n    if (\n      !options.android.extension ||\n      !options.ios.extension ||\n      !extensionRegex.test(options.android.extension) ||\n      !extensionRegex.test(options.ios.extension)\n    ) {\n      throw new Error(`Your file extensions must match ${extensionRegex.toString()}.`);\n    }\n\n    if (!this._canRecord) {\n      if (eventEmitter) {\n        this._subscription = eventEmitter.addListener(\n          'Expo.Recording.recorderUnloaded',\n          this._cleanupForUnloadedRecorder\n        );\n      }\n\n      const {\n        uri,\n        status,\n      }: {\n        uri: string | null;\n        // status is of type RecordingStatus, but without the canRecord field populated\n        status: Pick<RecordingStatus, Exclude<keyof RecordingStatus, 'canRecord'>>;\n      } = await ExponentAV.prepareAudioRecorder(options);\n      _recorderExists = true;\n      this._uri = uri;\n      this._options = options;\n      this._canRecord = true;\n\n      const currentStatus = { ...status, canRecord: true };\n      this._callOnRecordingStatusUpdateForNewStatus(currentStatus);\n      this._enablePollingIfNecessaryAndPossible();\n      return currentStatus;\n    } else {\n      throw new Error('This Recording object is already prepared to record.');\n    }\n  }\n\n  /**\n   * Returns a list of available recording inputs. This method can only be called if the `Recording` has been prepared.\n   * @return A `Promise` that is fulfilled with an array of `RecordingInput` objects.\n   */\n  async getAvailableInputs(): Promise<RecordingInput[]> {\n    return ExponentAV.getAvailableInputs();\n  }\n\n  /**\n   * Returns the currently-selected recording input. This method can only be called if the `Recording` has been prepared.\n   * @return A `Promise` that is fulfilled with a `RecordingInput` object.\n   */\n  async getCurrentInput(): Promise<RecordingInput> {\n    return ExponentAV.getCurrentInput();\n  }\n\n  /**\n   * Sets the current recording input.\n   * @param inputUid The uid of a `RecordingInput`.\n   * @return A `Promise` that is resolved if successful or rejected if not.\n   */\n  async setInput(inputUid: string): Promise<void> {\n    return ExponentAV.setInput(inputUid);\n  }\n\n  /**\n   * Begins recording. This method can only be called if the `Recording` has been prepared.\n   * @return A `Promise` that is fulfilled when recording has begun, or rejects if recording could not be started.\n   * The promise is resolved with the `RecordingStatus` of the recording.\n   */\n  async startAsync(): Promise<RecordingStatus> {\n    return this._performOperationAndHandleStatusAsync(() => ExponentAV.startAudioRecording());\n  }\n\n  /**\n   * Pauses recording. This method can only be called if the `Recording` has been prepared.\n   *\n   * > This is only available on Android API version 24 and later.\n   *\n   * @return A `Promise` that is fulfilled when recording has paused, or rejects if recording could not be paused.\n   * If the Android API version is less than 24, the `Promise` will reject. The promise is resolved with the\n   * `RecordingStatus` of the recording.\n   */\n  async pauseAsync(): Promise<RecordingStatus> {\n    return this._performOperationAndHandleStatusAsync(() => ExponentAV.pauseAudioRecording());\n  }\n\n  /**\n   * Stops the recording and deallocates the recorder from memory. This reverts the `Recording` instance\n   * to an unprepared state, and another `Recording` instance must be created in order to record again.\n   * This method can only be called if the `Recording` has been prepared.\n   *\n   * > On Android this method may fail with `E_AUDIO_NODATA` when called too soon after `startAsync` and\n   * > no audio data has been recorded yet. In that case the recorded file will be invalid and should be discarded.\n   *\n   * @return A `Promise` that is fulfilled when recording has stopped, or rejects if recording could not be stopped.\n   * The promise is resolved with the `RecordingStatus` of the recording.\n   */\n  async stopAndUnloadAsync(): Promise<RecordingStatus> {\n    if (!this._canRecord) {\n      if (this._isDoneRecording) {\n        throw new Error('Cannot unload a Recording that has already been unloaded.');\n      } else {\n        throw new Error('Cannot unload a Recording that has not been prepared.');\n      }\n    }\n    // We perform a separate native API call so that the state of the Recording can be updated with\n    // the final duration of the recording. (We cast stopStatus as Object to appease Flow)\n    let stopResult: RecordingStatus | undefined;\n    let stopError: Error | undefined;\n    try {\n      stopResult = await ExponentAV.stopAudioRecording();\n    } catch (err) {\n      stopError = err;\n    }\n\n    // Web has to return the URI at the end of recording, so needs a little destructuring\n    if (Platform.OS === 'web' && stopResult?.uri !== undefined) {\n      this._uri = stopResult.uri;\n    }\n\n    // Clean-up and return status\n    await ExponentAV.unloadAudioRecorder();\n    const status = await this._cleanupForUnloadedRecorder(stopResult);\n    return stopError ? Promise.reject(stopError) : status;\n  }\n\n  // Read API\n\n  /**\n   * Gets the local URI of the `Recording`. Note that this will only succeed once the `Recording` is prepared\n   * to record. On web, this will not return the URI until the recording is finished.\n   * @return A `string` with the local URI of the `Recording`, or `null` if the `Recording` is not prepared\n   * to record (or, on Web, if the recording has not finished).\n   */\n  getURI(): string | null {\n    return this._uri;\n  }\n\n  /**\n   * @deprecated Use `createNewLoadedSoundAsync()` instead.\n   */\n  async createNewLoadedSound(\n    initialStatus: AVPlaybackStatusToSet = {},\n    onPlaybackStatusUpdate: ((status: AVPlaybackStatus) => void) | null = null\n  ): Promise<SoundObject> {\n    console.warn(\n      `createNewLoadedSound is deprecated in favor of createNewLoadedSoundAsync, which has the same API aside from the method name`\n    );\n    return this.createNewLoadedSoundAsync(initialStatus, onPlaybackStatusUpdate);\n  }\n\n  /**\n   * Creates and loads a new `Sound` object to play back the `Recording`. Note that this will only succeed once the `Recording`\n   * is done recording and `stopAndUnloadAsync()` has been called.\n   *\n   * @param initialStatus The initial intended `PlaybackStatusToSet` of the sound, whose values will override the default initial playback status.\n   * This value defaults to `{}` if no parameter is passed. See the [AV documentation](/versions/latest/sdk/av) for details on `PlaybackStatusToSet`\n   * and the default initial playback status.\n   * @param onPlaybackStatusUpdate A function taking a single parameter `PlaybackStatus`. This value defaults to `null` if no parameter is passed.\n   * See the [AV documentation](/versions/latest/sdk/av) for details on the functionality provided by `onPlaybackStatusUpdate`\n   *\n   * @return A `Promise` that is rejected if creation failed, or fulfilled with the `SoundObject`.\n   */\n  async createNewLoadedSoundAsync(\n    initialStatus: AVPlaybackStatusToSet = {},\n    onPlaybackStatusUpdate: ((status: AVPlaybackStatus) => void) | null = null\n  ): Promise<SoundObject> {\n    if (this._uri == null || !this._isDoneRecording) {\n      throw new Error('Cannot create sound when the Recording has not finished!');\n    }\n    return Sound.createAsync(\n      // $FlowFixMe: Flow can't distinguish between this literal and Asset\n      { uri: this._uri },\n      initialStatus,\n      onPlaybackStatusUpdate,\n      false\n    );\n  }\n}\n\nexport { PermissionResponse, PermissionStatus, PermissionHookOptions };\n\nexport * from './RecordingConstants';\n\nexport * from './Recording.types';\n"]},"metadata":{},"sourceType":"module"}