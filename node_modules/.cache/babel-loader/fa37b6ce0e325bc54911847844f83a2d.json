{"ast":null,"code":"import { Asset } from 'expo-asset';\nimport { Platform } from 'expo-modules-core';\nimport { PitchCorrectionQuality } from './AV.types';\n// TODO add:\n//  disableFocusOnAndroid\n//  audio routes (at least did become noisy on android)\n//  pan\n//  pitch\n//  API to explicitly request audio focus / session\n//  API to select stream type on Android\n//  subtitles API\n/**\n * @hidden\n */\nexport const _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS = 500;\n// @needsAudit\n/**\n * The default initial `AVPlaybackStatusToSet` of all `Audio.Sound` objects and `Video` components is as follows:\n *\n * ```javascript\n * {\n *   progressUpdateIntervalMillis: 500,\n *   positionMillis: 0,\n *   shouldPlay: false,\n *   rate: 1.0,\n *   shouldCorrectPitch: false,\n *   volume: 1.0,\n *   isMuted: false,\n *   isLooping: false,\n * }\n * ```\n *\n * This default initial status can be overwritten by setting the optional `initialStatus` in `loadAsync()` or `Audio.Sound.createAsync()`.\n */\nexport const _DEFAULT_INITIAL_PLAYBACK_STATUS = {\n  positionMillis: 0,\n  progressUpdateIntervalMillis: _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS,\n  shouldPlay: false,\n  rate: 1.0,\n  shouldCorrectPitch: false,\n  volume: 1.0,\n  isMuted: false,\n  isLooping: false\n};\n// @needsAudit\n/**\n * @hidden\n */\nexport function getNativeSourceFromSource(source) {\n  let uri = null;\n  let overridingExtension = null;\n  let headers;\n  if (typeof source === 'string' && Platform.OS === 'web') {\n    return {\n      uri: source,\n      overridingExtension,\n      headers\n    };\n  }\n  const asset = _getAssetFromPlaybackSource(source);\n  if (asset != null) {\n    uri = asset.localUri || asset.uri;\n  } else if (source != null && typeof source !== 'number' && 'uri' in source && typeof source.uri === 'string') {\n    uri = source.uri;\n  }\n  if (uri == null) {\n    return null;\n  }\n  if (source != null && typeof source !== 'number' && 'overrideFileExtensionAndroid' in source && typeof source.overrideFileExtensionAndroid === 'string') {\n    overridingExtension = source.overrideFileExtensionAndroid;\n  }\n  if (source != null && typeof source !== 'number' && 'headers' in source && typeof source.headers === 'object') {\n    headers = source.headers;\n  }\n  return {\n    uri,\n    overridingExtension,\n    headers\n  };\n}\nfunction _getAssetFromPlaybackSource(source) {\n  if (source == null) {\n    return null;\n  }\n  let asset = null;\n  if (typeof source === 'number') {\n    asset = Asset.fromModule(source);\n  } else if (source instanceof Asset) {\n    asset = source;\n  }\n  return asset;\n}\n// @needsAudit\n/**\n * @hidden\n */\nexport function assertStatusValuesInBounds(status) {\n  if (typeof status.rate === 'number' && (status.rate < 0 || status.rate > 32)) {\n    throw new RangeError('Rate value must be between 0.0 and 32.0');\n  }\n  if (typeof status.volume === 'number' && (status.volume < 0 || status.volume > 1)) {\n    throw new RangeError('Volume value must be between 0.0 and 1.0');\n  }\n}\n// @needsAudit\n/**\n * @hidden\n */\nexport async function getNativeSourceAndFullInitialStatusForLoadAsync(source, initialStatus, downloadFirst) {\n  // Get the full initial status\n  const fullInitialStatus = initialStatus == null ? _DEFAULT_INITIAL_PLAYBACK_STATUS : {\n    ..._DEFAULT_INITIAL_PLAYBACK_STATUS,\n    ...initialStatus\n  };\n  assertStatusValuesInBounds(fullInitialStatus);\n  if (typeof source === 'string' && Platform.OS === 'web') {\n    return {\n      nativeSource: {\n        uri: source,\n        overridingExtension: null\n      },\n      fullInitialStatus\n    };\n  }\n  // Download first if necessary.\n  const asset = _getAssetFromPlaybackSource(source);\n  if (downloadFirst && asset) {\n    // TODO we can download remote uri too once @nikki93 has integrated this into Asset\n    await asset.downloadAsync();\n  }\n  // Get the native source\n  const nativeSource = getNativeSourceFromSource(source);\n  if (nativeSource === null) {\n    throw new Error(`Cannot load an AV asset from a null playback source`);\n  }\n  // If asset has been downloaded use the localUri\n  if (asset && asset.localUri) {\n    nativeSource.uri = asset.localUri;\n  }\n  return {\n    nativeSource,\n    fullInitialStatus\n  };\n}\n// @needsAudit\n/**\n * @hidden\n */\nexport function getUnloadedStatus() {\n  let error = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  return {\n    isLoaded: false,\n    ...(error ? {\n      error\n    } : null)\n  };\n}\n/**\n * @hidden\n * A mixin that defines common playback methods for A/V classes, so they implement the `Playback`\n * interface.\n */\nexport const PlaybackMixin = {\n  async playAsync() {\n    return this.setStatusAsync({\n      shouldPlay: true\n    });\n  },\n  async playFromPositionAsync(positionMillis) {\n    let tolerances = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.setStatusAsync({\n      positionMillis,\n      shouldPlay: true,\n      seekMillisToleranceAfter: tolerances.toleranceMillisAfter,\n      seekMillisToleranceBefore: tolerances.toleranceMillisBefore\n    });\n  },\n  async pauseAsync() {\n    return this.setStatusAsync({\n      shouldPlay: false\n    });\n  },\n  async stopAsync() {\n    return this.setStatusAsync({\n      positionMillis: 0,\n      shouldPlay: false\n    });\n  },\n  async setPositionAsync(positionMillis) {\n    let tolerances = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.setStatusAsync({\n      positionMillis,\n      seekMillisToleranceAfter: tolerances.toleranceMillisAfter,\n      seekMillisToleranceBefore: tolerances.toleranceMillisBefore\n    });\n  },\n  async setRateAsync(rate) {\n    let shouldCorrectPitch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let pitchCorrectionQuality = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : PitchCorrectionQuality.Low;\n    return this.setStatusAsync({\n      rate,\n      shouldCorrectPitch,\n      pitchCorrectionQuality\n    });\n  },\n  async setVolumeAsync(volume) {\n    return this.setStatusAsync({\n      volume\n    });\n  },\n  async setIsMutedAsync(isMuted) {\n    return this.setStatusAsync({\n      isMuted\n    });\n  },\n  async setIsLoopingAsync(isLooping) {\n    return this.setStatusAsync({\n      isLooping\n    });\n  },\n  async setProgressUpdateIntervalAsync(progressUpdateIntervalMillis) {\n    return this.setStatusAsync({\n      progressUpdateIntervalMillis\n    });\n  }\n};\nexport * from './AV.types';","map":{"version":3,"mappings":"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","names":["Asset","Platform","PitchCorrectionQuality","_DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS","_DEFAULT_INITIAL_PLAYBACK_STATUS","positionMillis","progressUpdateIntervalMillis","shouldPlay","rate","shouldCorrectPitch","volume","isMuted","isLooping","getNativeSourceFromSource","source","uri","overridingExtension","headers","OS","asset","_getAssetFromPlaybackSource","localUri","overrideFileExtensionAndroid","fromModule","assertStatusValuesInBounds","status","RangeError","getNativeSourceAndFullInitialStatusForLoadAsync","initialStatus","downloadFirst","fullInitialStatus","nativeSource","downloadAsync","Error","getUnloadedStatus","error","isLoaded","PlaybackMixin","playAsync","setStatusAsync","playFromPositionAsync","tolerances","seekMillisToleranceAfter","toleranceMillisAfter","seekMillisToleranceBefore","toleranceMillisBefore","pauseAsync","stopAsync","setPositionAsync","setRateAsync","pitchCorrectionQuality","Low","setVolumeAsync","setIsMutedAsync","setIsLoopingAsync","setProgressUpdateIntervalAsync"],"sources":["/Users/noname/WebstormProjects/webapplastdesire/node_modules/expo-av/src/AV.ts"],"sourcesContent":["import { Asset } from 'expo-asset';\nimport { Platform } from 'expo-modules-core';\n\nimport {\n  AVPlaybackSource,\n  AVPlaybackNativeSource,\n  AVPlaybackStatus,\n  AVPlaybackStatusToSet,\n  PitchCorrectionQuality,\n  AVPlaybackTolerance,\n} from './AV.types';\n\n// TODO add:\n//  disableFocusOnAndroid\n//  audio routes (at least did become noisy on android)\n//  pan\n//  pitch\n//  API to explicitly request audio focus / session\n//  API to select stream type on Android\n//  subtitles API\n\n/**\n * @hidden\n */\nexport const _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS: number = 500;\n\n// @needsAudit\n/**\n * The default initial `AVPlaybackStatusToSet` of all `Audio.Sound` objects and `Video` components is as follows:\n *\n * ```javascript\n * {\n *   progressUpdateIntervalMillis: 500,\n *   positionMillis: 0,\n *   shouldPlay: false,\n *   rate: 1.0,\n *   shouldCorrectPitch: false,\n *   volume: 1.0,\n *   isMuted: false,\n *   isLooping: false,\n * }\n * ```\n *\n * This default initial status can be overwritten by setting the optional `initialStatus` in `loadAsync()` or `Audio.Sound.createAsync()`.\n */\nexport const _DEFAULT_INITIAL_PLAYBACK_STATUS: AVPlaybackStatusToSet = {\n  positionMillis: 0,\n  progressUpdateIntervalMillis: _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS,\n  shouldPlay: false,\n  rate: 1.0,\n  shouldCorrectPitch: false,\n  volume: 1.0,\n  isMuted: false,\n  isLooping: false,\n};\n\n// @needsAudit\n/**\n * @hidden\n */\nexport function getNativeSourceFromSource(\n  source?: AVPlaybackSource | null\n): AVPlaybackNativeSource | null {\n  let uri: string | null = null;\n  let overridingExtension: string | null = null;\n  let headers: AVPlaybackNativeSource['headers'];\n\n  if (typeof source === 'string' && Platform.OS === 'web') {\n    return {\n      uri: source,\n      overridingExtension,\n      headers,\n    };\n  }\n\n  const asset: Asset | null = _getAssetFromPlaybackSource(source);\n  if (asset != null) {\n    uri = asset.localUri || asset.uri;\n  } else if (\n    source != null &&\n    typeof source !== 'number' &&\n    'uri' in source &&\n    typeof source.uri === 'string'\n  ) {\n    uri = source.uri;\n  }\n\n  if (uri == null) {\n    return null;\n  }\n\n  if (\n    source != null &&\n    typeof source !== 'number' &&\n    'overrideFileExtensionAndroid' in source &&\n    typeof source.overrideFileExtensionAndroid === 'string'\n  ) {\n    overridingExtension = source.overrideFileExtensionAndroid;\n  }\n\n  if (\n    source != null &&\n    typeof source !== 'number' &&\n    'headers' in source &&\n    typeof source.headers === 'object'\n  ) {\n    headers = source.headers;\n  }\n  return { uri, overridingExtension, headers };\n}\n\nfunction _getAssetFromPlaybackSource(source?: AVPlaybackSource | null): Asset | null {\n  if (source == null) {\n    return null;\n  }\n\n  let asset: Asset | null = null;\n  if (typeof source === 'number') {\n    asset = Asset.fromModule(source);\n  } else if (source instanceof Asset) {\n    asset = source;\n  }\n  return asset;\n}\n\n// @needsAudit\n/**\n * @hidden\n */\nexport function assertStatusValuesInBounds(status: AVPlaybackStatusToSet): void {\n  if (typeof status.rate === 'number' && (status.rate < 0 || status.rate > 32)) {\n    throw new RangeError('Rate value must be between 0.0 and 32.0');\n  }\n  if (typeof status.volume === 'number' && (status.volume < 0 || status.volume > 1)) {\n    throw new RangeError('Volume value must be between 0.0 and 1.0');\n  }\n}\n\n// @needsAudit\n/**\n * @hidden\n */\nexport async function getNativeSourceAndFullInitialStatusForLoadAsync(\n  source: AVPlaybackSource | null,\n  initialStatus: AVPlaybackStatusToSet | null,\n  downloadFirst: boolean\n): Promise<{\n  nativeSource: AVPlaybackNativeSource;\n  fullInitialStatus: AVPlaybackStatusToSet;\n}> {\n  // Get the full initial status\n  const fullInitialStatus: AVPlaybackStatusToSet =\n    initialStatus == null\n      ? _DEFAULT_INITIAL_PLAYBACK_STATUS\n      : {\n          ..._DEFAULT_INITIAL_PLAYBACK_STATUS,\n          ...initialStatus,\n        };\n  assertStatusValuesInBounds(fullInitialStatus);\n\n  if (typeof source === 'string' && Platform.OS === 'web') {\n    return {\n      nativeSource: {\n        uri: source,\n        overridingExtension: null,\n      },\n      fullInitialStatus,\n    };\n  }\n\n  // Download first if necessary.\n  const asset = _getAssetFromPlaybackSource(source);\n  if (downloadFirst && asset) {\n    // TODO we can download remote uri too once @nikki93 has integrated this into Asset\n    await asset.downloadAsync();\n  }\n\n  // Get the native source\n  const nativeSource: AVPlaybackNativeSource | null = getNativeSourceFromSource(source);\n\n  if (nativeSource === null) {\n    throw new Error(`Cannot load an AV asset from a null playback source`);\n  }\n\n  // If asset has been downloaded use the localUri\n  if (asset && asset.localUri) {\n    nativeSource.uri = asset.localUri;\n  }\n\n  return { nativeSource, fullInitialStatus };\n}\n\n// @needsAudit\n/**\n * @hidden\n */\nexport function getUnloadedStatus(error: string | null = null): AVPlaybackStatus {\n  return {\n    isLoaded: false,\n    ...(error ? { error } : null),\n  };\n}\n\n// @needsAudit\nexport interface AV {\n  /**\n   * Sets a new `AVPlaybackStatusToSet` on the `playbackObject`. This method can only be called if the media has been loaded.\n   * @param status The new `AVPlaybackStatusToSet` of the `playbackObject`, whose values will override the current playback status.\n   * @return A `Promise` that is fulfilled with the `AVPlaybackStatus` of the `playbackObject` once the new status has been set successfully,\n   * or rejects if setting the new status failed. See below for details on `AVPlaybackStatus`.\n   */\n  setStatusAsync(status: AVPlaybackStatusToSet): Promise<AVPlaybackStatus>;\n\n  /**\n   * Gets the `AVPlaybackStatus` of the `playbackObject`.\n   * @return A `Promise` that is fulfilled with the `AVPlaybackStatus` of the `playbackObject`.\n   */\n  getStatusAsync(): Promise<AVPlaybackStatus>;\n}\n\n// @needsAudit\n/**\n * On the `playbackObject` reference, the following API is provided.\n */\nexport interface Playback extends AV {\n  /**\n   * This is equivalent to `playbackObject.setStatusAsync({ shouldPlay: true })`.\n   *\n   * Playback may not start immediately after calling this function for reasons such as buffering. Make sure to update your UI based\n   * on the `isPlaying` and `isBuffering` properties of the `AVPlaybackStatus`.\n   */\n  playAsync(): Promise<AVPlaybackStatus>;\n\n  /**\n   * Loads the media from `source` into memory and prepares it for playing. This must be called before calling `setStatusAsync()`\n   * or any of the convenience set status methods. This method can only be called if the `playbackObject` is in an unloaded state.\n   * @param source The source of the media.\n   * @param initialStatus The initial intended `AVPlaybackStatusToSet` of the `playbackObject`, whose values will override the default initial playback status.\n   * This value defaults to `{}` if no parameter is passed. For more information see the details on `AVPlaybackStatusToSet` type\n   * and the default initial playback status.\n   * @param downloadAsync If set to `true`, the system will attempt to download the resource to the device before loading.\n   * This value defaults to `true`. Note that at the moment, this will only work for `source`s of the form `require('path/to/file')` or `Asset` objects.\n   * @return A `Promise` that is fulfilled with the `AVPlaybackStatus` of the `playbackObject` once it is loaded, or rejects if loading failed.\n   * The `Promise` will also reject if the `playbackObject` was already loaded. See below for details on `AVPlaybackStatus`.\n   */\n  loadAsync(\n    source: AVPlaybackSource,\n    initialStatus?: AVPlaybackStatusToSet,\n    downloadAsync?: boolean\n  ): Promise<AVPlaybackStatus>;\n\n  /**\n   * Unloads the media from memory. `loadAsync()` must be called again in order to be able to play the media.\n   * > This cleanup function will be automatically called in the `Video` component's `componentWillUnmount`.\n   * @return A `Promise` that is fulfilled with the `AVPlaybackStatus` of the `playbackObject` once it is unloaded, or rejects if unloading failed.\n   */\n  unloadAsync(): Promise<AVPlaybackStatus>;\n\n  /**\n   * This is equivalent to `playbackObject.setStatusAsync({ shouldPlay: true, positionMillis, seekMillisToleranceAfter: tolerances.seekMillisToleranceAfter, seekMillisToleranceBefore: tolerances.seekMillisToleranceBefore })`.\n   *\n   * Playback may not start immediately after calling this function for reasons such as buffering. Make sure to update your UI based\n   * on the `isPlaying` and `isBuffering` properties of the `AVPlaybackStatus`.\n   * @param positionMillis The desired position of playback in milliseconds.\n   * @param tolerances The tolerances are used only on iOS ([more details](#what-is-seek-tolerance-and-why-would)).\n   */\n  playFromPositionAsync(\n    positionMillis: number,\n    tolerances?: AVPlaybackTolerance\n  ): Promise<AVPlaybackStatus>;\n\n  /**\n   * This is equivalent to `playbackObject.setStatusAsync({ shouldPlay: false })`.\n   */\n  pauseAsync(): Promise<AVPlaybackStatus>;\n\n  /**\n   * This is equivalent to `playbackObject.setStatusAsync({ shouldPlay: false, positionMillis: 0 })`.\n   */\n  stopAsync(): Promise<AVPlaybackStatus>;\n\n  /**\n   * Replays the playback item. When using `playFromPositionAsync(0)` the item is seeked to the position at `0 ms`.\n   * On iOS this method uses internal implementation of the player and is able to play the item from the beginning immediately.\n   * @param status The new `AVPlaybackStatusToSet` of the `playbackObject`, whose values will override the current playback status.\n   * `positionMillis` and `shouldPlay` properties will be overridden with respectively `0` and `true`.\n   * @return A `Promise` that is fulfilled with the `AVPlaybackStatus` of the `playbackObject` once the new status has been set successfully,\n   * or rejects if setting the new status failed.\n   */\n  replayAsync(status: AVPlaybackStatusToSet): Promise<AVPlaybackStatus>;\n\n  /**\n   * This is equivalent to `playbackObject.setStatusAsync({ positionMillis })`.\n   * @param positionMillis The desired position of playback in milliseconds.\n   * @param tolerances The tolerances are used only on iOS ([more details](#what-is-seek-tolerance-and-why-would)).\n   */\n  setPositionAsync(\n    positionMillis: number,\n    tolerances?: AVPlaybackTolerance\n  ): Promise<AVPlaybackStatus>;\n\n  /**\n   * This is equivalent to `playbackObject.setStatusAsync({ rate, shouldCorrectPitch, pitchCorrectionQuality })`.\n   * @param rate The desired playback rate of the media. This value must be between `0.0` and `32.0`. Only available on Android API version 23 and later and iOS.\n   * @param shouldCorrectPitch A boolean describing if we should correct the pitch for a changed rate. If set to `true`, the pitch of the audio will be corrected\n   * (so a rate different than `1.0` will timestretch the audio).\n   * @param pitchCorrectionQuality iOS time pitch algorithm setting, defaults to `Audio.PitchCorrectionQuality.Low`.\n   */\n  setRateAsync(\n    rate: number,\n    shouldCorrectPitch: boolean,\n    pitchCorrectionQuality?: PitchCorrectionQuality\n  ): Promise<AVPlaybackStatus>;\n\n  /**\n   * This is equivalent to `playbackObject.setStatusAsync({ volume })`.\n   * @param volume A number between `0.0` (silence) and `1.0` (maximum volume).\n   */\n  setVolumeAsync(volume: number): Promise<AVPlaybackStatus>;\n\n  /**\n   * This is equivalent to `playbackObject.setStatusAsync({ isMuted })`.\n   * @param isMuted A boolean describing if the audio of this media should be muted.\n   */\n  setIsMutedAsync(isMuted: boolean): Promise<AVPlaybackStatus>;\n\n  /**\n   * This is equivalent to `playbackObject.setStatusAsync({ isLooping })`.\n   * @param isLooping A boolean describing if the media should play once (`false`) or loop indefinitely (`true`).\n   */\n  setIsLoopingAsync(isLooping: boolean): Promise<AVPlaybackStatus>;\n\n  /**\n   * This is equivalent to `playbackObject.setStatusAsync({ progressUpdateIntervalMillis })`.\n   * @param progressUpdateIntervalMillis The new minimum interval in milliseconds between calls of `onPlaybackStatusUpdate`.\n   * See `setOnPlaybackStatusUpdate()` for details.\n   */\n  setProgressUpdateIntervalAsync(progressUpdateIntervalMillis: number): Promise<AVPlaybackStatus>;\n}\n\n/**\n * @hidden\n * A mixin that defines common playback methods for A/V classes, so they implement the `Playback`\n * interface.\n */\nexport const PlaybackMixin = {\n  async playAsync(): Promise<AVPlaybackStatus> {\n    return (this as any as Playback).setStatusAsync({ shouldPlay: true });\n  },\n\n  async playFromPositionAsync(\n    positionMillis: number,\n    tolerances: AVPlaybackTolerance = {}\n  ): Promise<AVPlaybackStatus> {\n    return (this as any as Playback).setStatusAsync({\n      positionMillis,\n      shouldPlay: true,\n      seekMillisToleranceAfter: tolerances.toleranceMillisAfter,\n      seekMillisToleranceBefore: tolerances.toleranceMillisBefore,\n    });\n  },\n\n  async pauseAsync(): Promise<AVPlaybackStatus> {\n    return (this as any as Playback).setStatusAsync({ shouldPlay: false });\n  },\n\n  async stopAsync(): Promise<AVPlaybackStatus> {\n    return (this as any as Playback).setStatusAsync({ positionMillis: 0, shouldPlay: false });\n  },\n\n  async setPositionAsync(\n    positionMillis: number,\n    tolerances: AVPlaybackTolerance = {}\n  ): Promise<AVPlaybackStatus> {\n    return (this as any as Playback).setStatusAsync({\n      positionMillis,\n      seekMillisToleranceAfter: tolerances.toleranceMillisAfter,\n      seekMillisToleranceBefore: tolerances.toleranceMillisBefore,\n    });\n  },\n\n  async setRateAsync(\n    rate: number,\n    shouldCorrectPitch: boolean = false,\n    pitchCorrectionQuality: PitchCorrectionQuality = PitchCorrectionQuality.Low\n  ): Promise<AVPlaybackStatus> {\n    return (this as any as Playback).setStatusAsync({\n      rate,\n      shouldCorrectPitch,\n      pitchCorrectionQuality,\n    });\n  },\n\n  async setVolumeAsync(volume: number): Promise<AVPlaybackStatus> {\n    return (this as any as Playback).setStatusAsync({ volume });\n  },\n\n  async setIsMutedAsync(isMuted: boolean): Promise<AVPlaybackStatus> {\n    return (this as any as Playback).setStatusAsync({ isMuted });\n  },\n\n  async setIsLoopingAsync(isLooping: boolean): Promise<AVPlaybackStatus> {\n    return (this as any as Playback).setStatusAsync({ isLooping });\n  },\n\n  async setProgressUpdateIntervalAsync(\n    progressUpdateIntervalMillis: number\n  ): Promise<AVPlaybackStatus> {\n    return (this as any as Playback).setStatusAsync({ progressUpdateIntervalMillis });\n  },\n};\n\nexport * from './AV.types';\n"]},"metadata":{},"sourceType":"module"}