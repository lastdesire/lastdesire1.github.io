{"ast":null,"code":"import { Platform } from 'expo-modules-core';\nimport path from 'path-browserify';\nimport { PixelRatio } from 'react-native';\nimport URL from 'url-parse';\nimport AssetSourceResolver from './AssetSourceResolver';\nimport { manifestBaseUrl, getManifest, getManifest2 } from './PlatformUtils';\n// Fast lookup check if asset map has any overrides in the manifest\nconst assetMapOverride = getManifest().assetMapOverride;\n/**\n * Selects the best file for the given asset (ex: choosing the best scale for images) and returns\n * a { uri, hash } pair for the specific asset file.\n *\n * If the asset isn't an image with multiple scales, the first file is selected.\n */\nexport function selectAssetSource(meta) {\n  // Override with the asset map in manifest if available\n  if (assetMapOverride && assetMapOverride.hasOwnProperty(meta.hash)) {\n    meta = {\n      ...meta,\n      ...assetMapOverride[meta.hash]\n    };\n  }\n  // This logic is based on that of AssetSourceResolver, with additional support for file hashes and\n  // explicitly provided URIs\n  const scale = AssetSourceResolver.pickScale(meta.scales, PixelRatio.get());\n  const index = meta.scales.findIndex(s => s === scale);\n  const hash = meta.fileHashes ? meta.fileHashes[index] || meta.fileHashes[0] : meta.hash;\n  // Allow asset processors to directly provide the URL to load\n  const uri = meta.fileUris ? meta.fileUris[index] || meta.fileUris[0] : meta.uri;\n  if (uri) {\n    return {\n      uri: resolveUri(uri),\n      hash\n    };\n  }\n  // Check if the assetUrl was overridden in the manifest\n  const assetUrlOverride = getManifest().assetUrlOverride;\n  if (assetUrlOverride) {\n    const uri = path.join(assetUrlOverride, hash);\n    return {\n      uri: resolveUri(uri),\n      hash\n    };\n  }\n  const fileScale = scale === 1 ? '' : `@${scale}x`;\n  const fileExtension = meta.type ? `.${encodeURIComponent(meta.type)}` : '';\n  const suffix = `/${encodeURIComponent(meta.name)}${fileScale}${fileExtension}?platform=${encodeURIComponent(Platform.OS)}&hash=${encodeURIComponent(meta.hash)}`;\n  // For assets with a specified absolute URL, we use the existing origin instead of prepending the\n  // development server or production CDN URL origin\n  if (/^https?:\\/\\//.test(meta.httpServerLocation)) {\n    const uri = meta.httpServerLocation + suffix;\n    return {\n      uri,\n      hash\n    };\n  }\n  // For assets during development using manifest2, we use the development server's URL origin\n  const manifest2 = getManifest2();\n  if (manifest2?.extra?.expoGo?.developer) {\n    const baseUrl = new URL(`http://${manifest2.extra.expoGo.debuggerHost}`);\n    baseUrl.set('pathname', meta.httpServerLocation + suffix);\n    return {\n      uri: baseUrl.href,\n      hash\n    };\n  }\n  // For assets during development, we use the development server's URL origin\n  if (getManifest().developer) {\n    const baseUrl = new URL(getManifest().bundleUrl);\n    baseUrl.set('pathname', meta.httpServerLocation + suffix);\n    return {\n      uri: baseUrl.href,\n      hash\n    };\n  }\n  // Production CDN URIs are based on each asset file hash\n  return {\n    uri: `https://classic-assets.eascdn.net/~assets/${encodeURIComponent(hash)}`,\n    hash\n  };\n}\n/**\n * Resolves the given URI to an absolute URI. If the given URI is already an absolute URI, it is\n * simply returned. Otherwise, if it is a relative URI, it is resolved relative to the manifest's\n * base URI.\n */\nexport function resolveUri(uri) {\n  if (!manifestBaseUrl) {\n    return uri;\n  }\n  const {\n    protocol\n  } = new URL(uri);\n  if (protocol !== '') {\n    return uri;\n  }\n  const baseUrl = new URL(manifestBaseUrl);\n  const resolvedPath = uri.startsWith('/') ? uri : path.join(baseUrl.pathname, uri);\n  baseUrl.set('pathname', resolvedPath);\n  return baseUrl.href;\n}","map":{"version":3,"mappings":"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","names":["Platform","path","PixelRatio","URL","AssetSourceResolver","manifestBaseUrl","getManifest","getManifest2","assetMapOverride","selectAssetSource","meta","hasOwnProperty","hash","scale","pickScale","scales","get","index","findIndex","s","fileHashes","uri","fileUris","resolveUri","assetUrlOverride","join","fileScale","fileExtension","type","encodeURIComponent","suffix","name","OS","test","httpServerLocation","manifest2","extra","expoGo","developer","baseUrl","debuggerHost","set","href","bundleUrl","protocol","resolvedPath","startsWith","pathname"],"sources":["/Users/noname/WebstormProjects/webapplastdesire/node_modules/expo-asset/src/AssetSources.ts"],"sourcesContent":["import { Platform } from 'expo-modules-core';\nimport path from 'path-browserify';\nimport { PixelRatio } from 'react-native';\nimport URL from 'url-parse';\n\nimport AssetSourceResolver from './AssetSourceResolver';\nimport { manifestBaseUrl, getManifest, getManifest2 } from './PlatformUtils';\n\n// @docsMissing\nexport type AssetMetadata = {\n  hash: string;\n  name: string;\n  type: string;\n  width?: number;\n  height?: number;\n  scales: number[];\n  httpServerLocation: string;\n  uri?: string;\n  fileHashes?: string[];\n  fileUris?: string[];\n};\n\nexport type AssetSource = {\n  uri: string;\n  hash: string;\n};\n\n// Fast lookup check if asset map has any overrides in the manifest\nconst assetMapOverride = getManifest().assetMapOverride;\n\n/**\n * Selects the best file for the given asset (ex: choosing the best scale for images) and returns\n * a { uri, hash } pair for the specific asset file.\n *\n * If the asset isn't an image with multiple scales, the first file is selected.\n */\nexport function selectAssetSource(meta: AssetMetadata): AssetSource {\n  // Override with the asset map in manifest if available\n  if (assetMapOverride && assetMapOverride.hasOwnProperty(meta.hash)) {\n    meta = { ...meta, ...assetMapOverride[meta.hash] };\n  }\n\n  // This logic is based on that of AssetSourceResolver, with additional support for file hashes and\n  // explicitly provided URIs\n  const scale = AssetSourceResolver.pickScale(meta.scales, PixelRatio.get());\n  const index = meta.scales.findIndex((s) => s === scale);\n  const hash = meta.fileHashes ? meta.fileHashes[index] || meta.fileHashes[0] : meta.hash;\n\n  // Allow asset processors to directly provide the URL to load\n  const uri = meta.fileUris ? meta.fileUris[index] || meta.fileUris[0] : meta.uri;\n  if (uri) {\n    return { uri: resolveUri(uri), hash };\n  }\n\n  // Check if the assetUrl was overridden in the manifest\n  const assetUrlOverride = getManifest().assetUrlOverride;\n  if (assetUrlOverride) {\n    const uri = path.join(assetUrlOverride, hash);\n    return { uri: resolveUri(uri), hash };\n  }\n\n  const fileScale = scale === 1 ? '' : `@${scale}x`;\n  const fileExtension = meta.type ? `.${encodeURIComponent(meta.type)}` : '';\n  const suffix = `/${encodeURIComponent(\n    meta.name\n  )}${fileScale}${fileExtension}?platform=${encodeURIComponent(\n    Platform.OS\n  )}&hash=${encodeURIComponent(meta.hash)}`;\n\n  // For assets with a specified absolute URL, we use the existing origin instead of prepending the\n  // development server or production CDN URL origin\n  if (/^https?:\\/\\//.test(meta.httpServerLocation)) {\n    const uri = meta.httpServerLocation + suffix;\n    return { uri, hash };\n  }\n\n  // For assets during development using manifest2, we use the development server's URL origin\n  const manifest2 = getManifest2();\n\n  if (manifest2?.extra?.expoGo?.developer) {\n    const baseUrl = new URL(`http://${manifest2.extra.expoGo.debuggerHost}`);\n    baseUrl.set('pathname', meta.httpServerLocation + suffix);\n\n    return {\n      uri: baseUrl.href,\n      hash,\n    };\n  }\n\n  // For assets during development, we use the development server's URL origin\n  if (getManifest().developer) {\n    const baseUrl = new URL(getManifest().bundleUrl);\n    baseUrl.set('pathname', meta.httpServerLocation + suffix);\n    return { uri: baseUrl.href, hash };\n  }\n\n  // Production CDN URIs are based on each asset file hash\n  return {\n    uri: `https://classic-assets.eascdn.net/~assets/${encodeURIComponent(hash)}`,\n    hash,\n  };\n}\n\n/**\n * Resolves the given URI to an absolute URI. If the given URI is already an absolute URI, it is\n * simply returned. Otherwise, if it is a relative URI, it is resolved relative to the manifest's\n * base URI.\n */\nexport function resolveUri(uri: string): string {\n  if (!manifestBaseUrl) {\n    return uri;\n  }\n\n  const { protocol } = new URL(uri);\n  if (protocol !== '') {\n    return uri;\n  }\n\n  const baseUrl = new URL(manifestBaseUrl);\n  const resolvedPath = uri.startsWith('/') ? uri : path.join(baseUrl.pathname, uri);\n  baseUrl.set('pathname', resolvedPath);\n  return baseUrl.href;\n}\n"]},"metadata":{},"sourceType":"module"}